<style>
table {
  border-collapse: collapse;
  width: 100%;
}

th, td {
  text-align: left;
  padding: 8px;
}

tr:nth-child(even) {background-color: #f2f2f2;}
</style>

<br>
<br>

# Binary relations and multiple quantifiers

We extend what we have learned so far to the case of binary relations.

<br>

- [Binary relations](#binary-relations)
- [Quantifiers and diagrams of binary relations](#quantifiers-and-diagrams-of-binary-relations)
- [Translations with binary relations](#translations-with-binary-relations)
- [Special classes of diagrams](#special-classes-of-diagrams)
- [Invalidity and binary relations](#invalidity-and-binary-relations)
- [Translating and relative clauses](#translating-and-relative-clauses)

<br>

<p style="page-break-before: always">

## Binary relations

Thus far we have been working with propositions like "All F are G" and "Some F are G", and their respective predicate logic analogues "$\forall \; x \; (Fx\rightarrow Gx)$" and "$\exists \; x \; (Fx\wedge Gx)$." If the objects in question are people, then it is individual people taken one-by-one that have these properties. Perhaps $Fa$ is true, and that is merely a matter of how things stand between the person picked out by $a$ and the relation $F$. And likewise perhaps $Fb$ is false, and that is again merely a matter of how things stand *vis-Ã -vis* the person picked out by $b$ and the collection of people picked out by $F$. But there are other properties that pertain to how individuals stand together with respect to one another and the property. For instance, if $a$ trusts $b$, then what makes that true is how things stand with $a$ and $b$ and trust, and it cannot intuitively be reduced to how things stand with respect to $a$ and trust alone and how things stand with respect to $b$ and trust alone. Properties which are involve two objects essentially are called *binary relations* or *two-place relations*. The name is chosen since properties like our F and G above which just involve one object are called *unary relations* or *one-place relations*.

Just like we diagrammatically represent unary relations with [Euler diagrams](https://carnap.io/shared/walsh@g.ucla.edu/book-pred-euler-venn.pandoc#euler-diagrams-of-the-first-figure), we can diagrammatically represent binary relations with arrow diagrams. The convention on the arrow diagrams is that a diagram represents $Rab$ if and only if there is an arrow drawn from $a$ to $b$. The sense of represents is "make true," and we will see how to formalize this in a later lecture.

<br>

*Example 1*:

The following diagram represents $(Rab \wedge Raa) \wedge (Rca \wedge Rac)$:

<video autoplay  muted width="400" src="https://logic-teaching.github.io/pred/vid/binary-1.mp4"/> </video>

<br>

*Example 2*:

The following diagram represents $Rac\wedge (Rca\wedge Rbd)$:

<video autoplay muted width="400" src="https://logic-teaching.github.io/pred/vid/binary-2.mp4"/> </video>

<br>

Note that the use of "arrow" in "arrow diagrams" is distinct from and not to be confused with the arrows that we use to formalize conditional statements. This rarely causes confusion because if e.g. one looked at the above diagram and saw the arrow from $b$ to $d$, one would not read this as $b\rightarrow d$, since per our conventions, the lower-case Latin letters in the first two-thirds of the Latin alphabet are reserved for constant symbols, which pick out objects and not propositions.

<br>

## Quantifiers and diagrams of binary relations

We can also represent quantified statements using diagrams.

*Example 3*:

The following diagram represents $\forall \; x \; Rax$:

<video autoplay muted width="400" src="https://logic-teaching.github.io/pred/vid/binary-3.mp4"/> </video>

<br>

Note that we have to add the arrow corresponding to $Raa$. This is because "$\forall \; x \; Rax$" means that "Everything is pointed to by an arrow from $a$", and this entails that "$a$ is pointed to by an arrow from $a$".

<br>

*Example 4*:

The following diagram represents $\forall \; x \; Rxx$:

<video autoplay muted width="400" src="https://logic-teaching.github.io/pred/vid/binary-4.mp4"/> </video>

<br>

It is harder to say express this sentence naturally using our prior methods. Perhaps the best we can do is "Everything points to itself."

In the diagrams we have been drawing, sometimes there are three constant symbols, and sometimes there are four. Any number of such symbols is allowed, although if one makes too few of them (say under 3) then it is hard to have them represent interesting sentences, and if one makes too many of them (say above 8), then they become harder to draw.


These examples merely pertained to one quantifier. We can also consider sentences involving multiple quantifiers.

*Example 5*:

The following diagram represents $\forall \;x \; \exists \; y \; Rxy$:

 <img src="https://logic-teaching.github.io/pred/vid/binary-5-part1.png
" alt="Diagram" width="400"/>

Intuitively, the truth of this comes down to the fact that each of the three arrows respectively implies:

1. $\exists \; y \; Ray$ ("$a$ points to something, namely $b$")
2. $\exists \; y \; Rby$ ("$b$ points to something, namely $c$")
3. $\exists \; y \; Rcy$ ("$c$ points to something, namely $c$")

Since there are only three constant symbols $a,b,c$ we have that the diagram represents $\forall \;x \; \exists \; y \; Rxy$. That is, "everything points to something." If we focus on the beginning of the arrows, we see that every dot is at the beginning of an arrow. To focus in this way, we might draw the beginning of the arrows in blue as follows:

 <img src="https://logic-teaching.github.io/pred/vid/binary-5-part2.png
" alt="Diagram" width="400"/>

When we do so, we see that "all dots are blue" is true is represented in the diagram.

<br>

*Example 6*:

The following diagram represents $\forall \; x \; \exists \; y \; Ryx$.

 <img src="https://logic-teaching.github.io/pred/vid/binary-6-part2.png
" alt="Diagram" width="400"/>

Again, this comes down to to the fact that each of the three arrows respectively imply:

1. $\exists \; y \; Rya$ ("$a$ is pointed to by something, namely $b$")
2. $\exists \; y \; Ryb$ ("$b$ is pointed to by something, namely $c$")
3. $\exists \; y \; Ryc$ ("$c$ is pointed to by something, namely $b$")

Since there are only three constant symbols $a,b,c$ we have that the diagram represents $\forall \; x \; \exists \; y \; Ryx$. That is "everything is pointed to by something." If we focus on the end of the arrows, we see that every dot is at the end of an arrow. To focus like this, we might draw the end of the arrows in orange as follows:

 <img src="https://logic-teaching.github.io/pred/vid/binary-6-part1.png
" alt="Diagram" width="400"/>

When we do so, we see that "all dots are orange" is represented in the diagram.



<br>

*Example 7*:

The following diagram represents $\exists \; y \; \forall \; x \; Rxy$.

 <img src="https://logic-teaching.github.io/pred/vid/binary-7.png
" alt="Diagram" width="400"/>

This is true since there is something, namely $a$ which everything points to. That is, $\exists \; y \; \forall \; x \; Rxy$ is represented in this diagram since the simpler fact $\forall \; x \; Rxa$ is. This simpler fact might be expressed as "everything points to $a$."

As this diagram indicates as well, it is not important to draw all of the dots on a line.

<br>

*Example 8*:

The following diagram represents $\exists \; x \; \forall \; y \; Rxy$.

 <img src="https://logic-teaching.github.io/pred/vid/binary-8.png
" alt="Diagram" width="400"/>

This is true since there is something, namely $b$, which points to everything. That is, $\exists \; x \; \forall \; y \; Rxy$ is represented in this diagram since the simpler fact $\forall \; y \; Rby$ is. This simpler fact may be put as "everything is pointed to by $b$."

<br>

## Translations with binary relations

There is a simple four-step procedure for translating into formulas like those in the previous section. We illustrate with respect to the binary relation of respects, which helpfully starts with the letter $R$.

<br>

*Example 9*:

Translate "Everyone respects someone".

Before describing the four-step process in words, here is a video of the process:

<video controls muted width="700" src="https://logic-teaching.github.io/pred/vid/binary-translation-1.mp4"/> </video>

<br>

1. *Split into noun-phrase and verb-phrase*. In our case, the noun-phrase is "everyone" and the verb-phrase is "$x$ respects someone" and we put a variable into the subject-position in the verb-phrase. It does not matter what variable you use.
2. *Translate the verb-phrase*. Since it involves "someone" we use the existential quantifier, and we translate as $\exists \; y \; Rxy$, since the someone in question, the $y$, is being respected by $x$. It does not matter what variable $y$ you use, so long as it is different than the variable you used in Step 1.
3. *Translate the noun-phrase*. Since the noun-phrase is "everyone", we translate with $\forall \;x$, using the same variable as in Step 1.
4. *Put them together*. We combine Step 3 + Step 2 to get "$\forall \; x \; \exists \; y \; Rxy$."

We can then input our answer here:

~~~{.Translate .FOL system="gamutND" submission="none"}
 AxEyRxy : Everyone respects someone.
|
~~~

Note that `AxEyRyx` would be an incorrect answer, and hence the order of the variables does matter: intuitively it corresponds to a difference between the active and the passive (respecting vs. being respected). Note that `AuEvRuv` would be a correct answer, since we are allowed some choice of variables in Step 1 and 2.

<br>

*Example 10*:

Translate "Everyone is respected by someone".

Before illustrating the four-step process, here is a video of the process:

<video controls muted width="700" src="https://logic-teaching.github.io/pred/vid/binary-translation-2.mp4"/> </video>

<br>

1. *Split into noun-phrase and verb-phrase*. In our case, the noun-phrase is "everyone" and the verb-phrase is "$u$ is respected someone" and we put a variable into the subject-position in the verb-phrase. It does not matter what variable you use.
2. *Translate the verb-phrase*. Since it involves "someone" we use the existential quantifier, and we translate as $\exists \; v \; Rvu$, since the someone in question, the $v$, is respecting our $u$. It does not matter what variable $v$ you use, so long as it is different than the variable you used in Step 1.
3. *Translate the noun-phrase*. Since the noun-phrase is "everyone", we translate with $\forall \;u$, using the same variable as in Step 1.
4. *Put them together*. We combine Step 3 + Step 2 to get "$\forall \; u \; \exists \; v \; Rvu$."

Let us input in our answer here:

~~~{.Translate .FOL system="gamutND" submission="none"}
 AuEvRvu : Everyone is respected by someone.
|
~~~

<br>

*Example 11*:

Translate "Someone is respected by everyone".

Prior to illustrating the four-step process again, here is a video:

<video controls muted width="700" src="https://logic-teaching.github.io/pred/vid/binary-translation-3.mp4"/> </video>

<br>

1. *Split into noun-phrase and verb-phrase*. In our case, the noun-phrase is "someone" and the verb-phrase is "$x$ is respected by everyone" and we put a variable into the subject-position in the verb-phrase. It does not matter what variable you use.
2. *Translate the verb-phrase*. Since it involves "everyone" we use the universal quantifier, and we translate as $\forall \; y \; Ryx$, since the every single $y$ is respecting our $x$. It does not matter what variable $y$ you use, so long as it is different than the variable you used in Step 1.
3. *Translate the noun-phrase*. Since the noun-phrase is "someone", we translate with $\exists \;x$, using the same variable as in Step 1.
4. *Put them together*. We combine Step 3 + Step 2 to get "$\exists \;x\; \forall \; y \; Ryx$."

We can then input our answer here:

~~~{.Translate .FOL system="gamutND" submission="none"}
 ExAyRyx : Someone is respected by everyone.
|
~~~

<br>

*Example 12*:

Translate "Someone respects everyone".

Again, we first show the video:

<video controls muted width="700" src="https://logic-teaching.github.io/pred/vid/binary-translation-4.mp4"/> </video>

<br>

1. *Split into noun-phrase and verb-phrase*. In our case, the noun-phrase is "someone" and the verb-phrase is "$z$ respects everyone" and we put a variable into the subject-position in the verb-phrase. It does not matter what variable you use.
2. *Translate the verb-phrase*. Since it involves "everyone" we use the universal quantifier, and we translate as $\forall \; y \; Rzy$, since the every single $y$ is being respected by our $x$. It does not matter what variable $y$ you use, so long as it is different than the variable you used in Step 1.
3. *Translate the noun-phrase*. Since the noun-phrase is "someone", we translate with $\exists \;z$, using the same variable as in Step 1.
4. *Put them together*. We combine Step 3 + Step 2 to get "$\exists \;z\; \forall \; y \; Rzy$."

We can again then input our answer:

~~~{.Translate .FOL system="gamutND" submission="none"}
 EzAyRzy : Someone respects everyone.
|
~~~

<br>

## Special classes of diagrams

We now describe some special classes of diagrams:

*Definition*. An arrow diagram is *reflexive* if it represents $\forall \;x \; Rxx$. That is, every dot has an arrow to itself.

*Definition*. An arrow diagram is *symmetry* if it represents $\forall \; x \; \forall \; y \; (Rxy\rightarrow Ryx)$. That is, for any two dots, if there is an arrow from the first to the second, then there is an arrow from the second to the first.

*Definition*. An arrow diagram is *transitive* if it represents $\forall \; x \; \forall \; \forall \; z \; ((Rxy\wedge Ryz)\rightarrow Rxz)$. That is, for any three dots, if there is an arrow from the first to the second and from the second to the third, then there is an arrow from the first to the third.

*Definition*. An arrow diagram is *an equivalence relation* if it is reflexive, symmetric, and transitive.

These first three definitions are independent of one another in that one can have one or two of the three properties but not the others represented in a diagram. Often it is typical to associate these definitions not with diagrams *per se* but rather with the binary relation $R$ itself. These definitions are very important in propositional modal logic since they are the root of the classical correspondence results. They can also be used to describe different kinds of ordering relations on number systems.

Here are four diagrams, named $M_1, M_2, M_3, M_4$:

 <img src="https://logic-teaching.github.io/pred/vid/binary-four-models.png
" alt="Diagram" width="700"/>

This table summarizes which of these features the four diagrams have:

<table style="width:100%">
  <tr>
    <th>Diagram</th>
    <th>Reflexive</th>
    <th>Symmetric</th>
    <th>Transitive</th>
    <th>Equivalence relation</th>
  </tr>
  <tr>
    <td>$M_1$</td>
    <td>yes </td>
    <td>no </td>
    <td>no </td>
    <td>no </td>
  </tr>
  <tr>
    <td>$M_2$</td>
    <td>no </td>
    <td>yes </td>
    <td>no </td>
    <td>no </td>
  </tr>
  <tr>
    <td>$M_3$</td>
    <td>no </td>
    <td>no </td>
    <td>yes </td>
    <td>no </td>
  </tr>
  <tr>
    <td>$M_1$</td>
    <td>yes </td>
    <td>yes </td>
    <td>yes </td>
    <td>yes </td>
  </tr>
</table>


These are lecture notes written by Sean Walsh. They are run on [carnap.io](http://www.carnap.io).[^5]

[^5]: which is:

<br>
