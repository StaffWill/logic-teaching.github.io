<style>
table {
  border-collapse: collapse;
  width: 100%;
}

th, td {
  text-align: left;
  padding: 8px;
}

tr:nth-child(even) {background-color: #f2f2f2;}
</style>

<br>
<br>

# Natural deduction for predicate logic, continued

We continue with our presentation of the natural deduction proof system, focusing on the rules for the existential quantifier, disjunction. We further discuss additional rules pertaining to falsum and negation.

- [The introduction rule for existential](#the-introduction-rule-for-existential)
- [The elimination rule for existential](#the-elimination-rule-for-existential)
- [Adding rules for the Aristotelian syllogism](#adding-rules-for-the-aristotelian-syllogism)


<br>
<br>

## The introduction rule for existential

The rule is: if you have $\phi(a)$ on line $\ell_1$, then you can write $\exists \; x \; \phi(x)$ on any subsequent line $\ell$, where $\phi(a)$ results from $\phi(x)$ by replacing all instances of $x$ by $a$.

<video controls width="600" src="https://logic-teaching.github.io/pred/vid/ND-IE-v2.mp4"/> </video>

<br>

Here are two simple examples of this rule:

*Example 1*

```{.ProofChecker .GamutNDPlus submission="none"}
 Rab :|-: ExEyRxy
|Rab :assumption
|EyRay :IE1
|ExEyRxy :IE2
```

<br>

*Example 2 (Third Conversion)*

```{.ProofChecker .GamutNDPlus submission="none"}
 ~Ex(Fx/\Gx) :|-: Ax(Fx->~Gx)
|~Ex(Fx/\Gx) :assumption
| Fc :assumption
|  Gc :assumption
|  Fc/\Gc :I/\2,3
|  Ex(Fx/\Gx) :IE4
|  ⊥ :E~1,5
| ~Gc :I~3-6
|Fc->~Gc :I->2-7
|Ax(Fx->~Gx) :IA8
```


<br>



## The elimination rule for existential

The rule is: if you have $\exists \; x \; \phi(x)$ on line $\ell_1$, and you have $\phi(c)\rightarrow \psi$ on line $\ell_2$ where $c$ does not occur in $\psi$ or in any open assumption, then you may write $\psi$ on any subsequent line $\ell>\ell_1, \ell_2$.

<video controls width="600" src="https://logic-teaching.github.io/pred/vid/ND-EE.mp4"/> </video>

Note that since the application of this rule requires you to get a conditional statement, you will usually have to apply arrow introduction to get the conditional.

<br>

*Example 3 (Darii)*

```{.ProofChecker .GamutNDPlus submission="none"}
Ax(Fx->Gx), Ex(Hx/\Fx)  :|-: Ex(Hx/\Gx)
|Ax(Fx->Gx) :assumption
|Ex(Hx/\Fx) :assumption
| Hc/\Fc :assumption
| Hc :E/\3
| Fc :E/\3
| Fc->Gc :EA1
| Gc :E->5,6
| Hc/\Gc :I/\4,7
| Ex(Hx/\Gx) :IE8
|(Hc/\Fc)->Ex(Hx/\Gx) :I->3-9
|Ex(Hx/\Gx) :EE2,10
```

*Example 4 (Ferio)*

```{.ProofChecker .GamutNDPlus submission="none"}
~Ex(Fx/\Gx), Ex(Hx/\Fx)  :|-: Ex(Hx/\~Gx)
|~Ex(Fx/\Gx) :assumption
|Ex(Hx/\Fx) :assumption
| Hc/\Fc :assumption
| Hc :E/\3
| Fc :E/\3
|  Gc :assumption
|  Fc/\Gc :I/\5,6
|  Ex(Fx/\Gx) :IE7
|  ⊥ :E~1,8
| ~Gc :I~6-9
| Hc/\~Gc :I/\4,10
| Ex(Hx/\~Gx) :IE11
|(Hc/\Fc)->Ex(Hx/\~Gx) :I->3-12
|Ex(Hx/\~Gx) :EE2,13
```

*Example 5 (First Conversion)*

```{.ProofChecker .GamutNDPlus submission="none"}
Ex(Fx/\Gx)  :|-: Ex(Gx/\Fx)
|Ex(Fx/\Gx) :assumption
| Fc/\Gc :assumption
| Fc :E/\2
| Gc :E/\2
| Gc/\Fc :I/\3,4
| Ex(Gx/\Fx) :IE5
|(Fc/\Gc)->Ex(Gx/\Fx) :I->2-6
|Ex(Gx/\Fx) :EE1,7
```

<br>

*Example 6 (Second Conversion)*

```{.ProofChecker .GamutNDPlus submission="none"}
~Ex(Fx/\Gx)  :|-: ~Ex(Gx/\Fx)
|~Ex(Fx/\Gx) :assumption
| Ex(Gx/\Fx) :assumption
|  Gc/\Fc :assumption
|  Gc :E/\3
|  Fc :E/\3
|  Fc/\Gc :I/\4-5
|  Ex(Fx/\Gx) :IE6
| (Gc/\Fc)->Ex(Fx/\Gx) :I->3-7
| Ex(Fx/\Gx) :EE2,8
| ⊥ :E~1,9
|~Ex(Gx/\Fx) :I~2-10
```

<br>

*Example 7 (Third Conversion)*

```{.ProofChecker .GamutNDPlus submission="none"}
 Ax(Fx->~Gx) :|-: ~Ex(Fx/\Gx)
|Ax(Fx->~Gx) :assumption
| Ex(Fx/\Gx) :assumption
|  Fc/\Gc :assumption
|  Fc :E/\3
|  Gc :E/\3
|  Fc->~Gc :EA1
|  ~Gc :EA4,6
|  ⊥ :E~5,7
| (Fc/\Gc)->⊥ :I->3-8
| ⊥ :EE2,9
|~Ex(Fx/\Gx) :I~2-10
```

<br>

*Example 8 (Fourth Conversion)*

```{.ProofChecker .GamutNDPlus submission="none"}
 Ax(Fx->Gx), ExFx :|-: ExGx
|Ax(Fx->Gx) :assumption
|ExFx :assumption
| Fc :assumption
| Fc->Gc :EA1
| Gc :E->3,4
| ExGx :IE5
|Fc->ExGx :I->3-6
|ExGx :EE2,7
```

<br>

*Example 9 (Celarent)*

```{.ProofChecker .GamutNDPlus submission="none"}
 ~Ex(Fx/\Gx), Ax(Hx->Fx) :|-: ~Ex(Hx/\Gx)
|~Ex(Fx/\Gx) :assumption
|Ax(Hx->Fx) :assumption
| Ex(Hx/\Gx) :assumption
|  Hc/\Gc :assumption
|  Hc :E/\4
|  Gc :E/\4
|  Hc->Fc :EA2
|  Fc :E->5,7
|  Fc/\Gc :I/\6,8
|  Ex(Fx/\Gx) :IE9
|  ⊥ :E~1,10
| (Hc/\Gc)->⊥ :I->4-11
| ⊥ :EE3,12
|~Ex(Hx/\Gx) :3-13
```

<br>

## Adding rules for the Aristotelian syllogism

We just showed that we can derive all of [the conversions and the first figure](https://carnap.io/shared/walsh@g.ucla.edu/book-pred-aristotelian.pandoc#summary-of-conversions-and-first-figure) from the  Aristotelian syllogisms in our system. So that we do not have to repeat these rules over and over again, we add them as primitive rules:

<table style="width:120%">
  <tr>
    <th>Name</th>
    <th>Rule name</th>
    <th>Formalization</th>
  </tr>
  <tr>
    <td>First Conversion</td>
    <td>`CV1`</td>
    <td>$\exists \; x \; (Fx\wedge Gx)\vdash \exists \; x \; (Gx\wedge Fx)$</td>
  </tr>
    <td>Second Conversion</td>
    <td>`CV2`</td>
    <td>$\neg \exists \; x \; (Fx\wedge Gx) \vdash \neg \exists \; x \; (Gx\wedge Fx)$</td>
  <tr>
    <td>Third Conversion</td>
    <td>`CV3`</td>
    <td>$\neg \exists \; x \; (Fx\wedge Gx) \vdash \forall \; x\; (Fx\rightarrow \neg Gx)$</td>
  </tr>
    <td>Fourth Conversion (with Existential Premise)</td>
    <td>`CV4`</td>
    <td>$\forall \; x \; (Fx\rightarrow Gx), \exists \; x \; Fx \vdash \exists \; x \; (Fx\wedge Gx)$</td>
  <tr>
    <td>Barbara</td>
    <td>`Ba`</td>
    <td>$\forall \; x \; (Fx\rightarrow Gx), \forall \; x \; (Gx\rightarrow Hx) \vdash \forall \; x \; (Fx\rightarrow Hx)$</td>
  </tr>
  <tr>
    <td>Celarent</td>
    <td>`Ce`</td>
    <td>$\neg \exists \; x \; (Fx\wedge Gx), \forall \; x \; (Hx\rightarrow Fx) \vdash \neg \exists \; x \; (Hx\wedge Gx)$</td>
  <tr>
    <td>Darii</td>
    <td>`Da`</td>
    <td>$\forall \; x \; (Fx\rightarrow Gx), \exists \; x \; (Hx \wedge Fx) \vdash \exists \; x \; (Hx \wedge Gx)$</td>
  </tr>
  <tr>
    <td>Ferio</td>
    <td>`Fe`</td>
    <td>$\neg \exists \; x \; (Fx\wedge Gx), \exists \; x \; (Hx\wedge Fx) \vdash \exists \; x \; (Hx\wedge \neg Gx)$</td>
  </tr>
</table>

<br>

*Example 10*

```{.ProofChecker .GamutNDPlus submission="none"}
 Ax(Fx->Gx), Ax(Gx->Hx), Ax(Hx->Mx) :|-: Ax(Fx->Mx)
|Ax(Fx->Gx) :assumption
|Ax(Gx->Hx) :assumption
|Ax(Hx->Mx) :assumption
|Ax(Fx->Hx) :Ba1,2
|Ax(Fx->Mx) :Ba3,4
```

<br>
