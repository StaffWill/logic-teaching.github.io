<br>
<br>

Logic, First Course, Winter 2020. Week 4, Lecture 1. [Back to course website](https://ccle.ucla.edu/course/view.php?id=82647&section=5)

# Quantification

In this lecture, we introduce quantification.


<br>

## Predicate logic and atomic statements

In propositional logic, we take as our basic unit the proposition, something that can be true or false. By taking it as the basic unit, we mean we do not subject it to any further analysis. For instance, while we translate "Christina is a student and Daisy is a student" as $p\wedge q$, we treat $p$ as a primitive and $q$ as primitives: they are basic. In predicate logic, the idea is to introduce another layer of analysis.
In particular, the most basic idea is to further analyze "Christina is a student" as $Sc$ and analyze "Dave is a student" as $Sd$. So we translate "Christina is a student and Dave is a student as" as $Sc\wedge Sd$.

One reason is that "Christina is a student" and "Dave is a student" seem to have a common structure. Someone couldn’t understand the one without understanding the other. And thereis  a common way to evaluate them: look at the list of students! So translating as $Sc$ and $Sd$ reveals this common structure. Here are some more examples, where we use the key:

| $a$  =  "Alyssa"
| $b$  =  "Bryan"
| $c$  =  "Christina"
| $d$  =  "Daisy"
| $L$  =  "is a lawyer"
| $M$  =  "is a musician"
| $H$  =  "likes hockey"
| $S$  =  "likes soccer"

<br>

~~~{.Translate .FOL system="gamutPND" submission="none"}
 L(a)/\M(b) : Alyssa is a lawyer and Bryan is a musician.
~~~

~~~{.Translate .FOL system="gamutPND" submission="none"}
 ~M(a)/\~L(b) : Alyssa is not a musician and Bryan is not a lawyer.
~~~

~~~{.Translate .FOL system="gamutPND" submission="none"}
 H(b)->H(c) : if Bryan likes hockey then Christina likes hockey.
~~~

~~~{.Translate .FOL system="gamutPND" submission="none"}
 H(c)\/M(d) : Christina likes hockey or Daisy is a musician.
~~~

<br>

## Motivating quantifiers

Consider the following three sentences.

1. Alyssa is nice.
2. Someone is nice. 
3. Everyone is nice.

There is an obvious sense in which all of these sentences are formed by plugging different words into the blank in “--- is nice.” This is an important perspective. But our translations are intended to display the way in which the truth of the whole depends on the truth of the parts. How the truth of the whole depends on the truth of the parts differs between 1-3. When we are trying to figure out whether Alyssa is nice” is true, we go look at Alyssa and see whether she is nice. To see whether “someone is nice” is true, we go searching for someone (perhaps Bryan?) who is nice. For “everyone is nice”, we need to make sure that Alyssa is nice, Bryan is nice, etc. And note that in thinking about sentence 1, we had said how to do that: to see whether Alyssa is nice, simply go look and see whether she is nice. Hence, the moral is: while recognizing the differences between 1-3, we should recognize the truth of 2-3 is somehow based on the truth-conditions of sentences like 1.


<br>

## The two quantifiers

Our solution is to translate these as follows:

1. $N(a)$
2. $\exists \; x \; N(x)$
3. $\forall \; x \; N(x)$

where we follow the key that $N(x)= x$ is nice, and $a=$ Alyssa. We pronounce $\exists \; x \; F(x)$ as "there is $x$ such that $F(x)$." We pronounce $\forall \; x \; F(x)$ as "for all all $x$, $F(x)$."

Note that in our translation of 2, the $x$ appears twice. The instance in $\exists \; x$ is a signal: go look for $d$ such that $N(d)$, where you get $N(d)$ from $N(x)$ by substituting in $x=d$. More generally, the rule for the truth of $\exists \; x \; F(x)$ is: it’s true exactly when there is at least one $d$ such that $F(d)$.

Similarly, in 3, the $x$ appears twice. The instance in $\forall \; x$ is a signal that one is making an "every" or "all" claim. And the rule for the truth of $\forall \; x \; F(x)$ is: it’s true exactly when $F(d)$ holds for each individual $d$.

Here are some examples using the key $N(x)= x$ is nice, and $a=$ Alyssa:

~~~{.Translate .FOL system="gamutPND" submission="none"}
 Ex(N(x))->Ax(N(x)) : If someone is nice then everyone is nice.
~~~

~~~{.Translate .FOL system="gamutPND" submission="none"}
 ~Ax(N(x)) : Not everyone is nice.
~~~

~~~{.Translate .FOL system="gamutPND" submission="none"}
 Ax(~N(x)) : Everyone is not nice.
~~~

~~~{.Translate .FOL system="gamutPND" submission="none"}
 N(a)->Ex(N(x)) : If Alyssa is nice then someone is nice.
~~~



<br>

These are lecture notes written for [this course](https://ccle.ucla.edu/course/view.php?id=82647&section=5).[^2]

[^2]:It is run on the Carnap software, which is
